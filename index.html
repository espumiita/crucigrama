<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>游빌 Crucigrama Aleatorio</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            /* AZULES (Tema principal) */
            --azul-marino-oscuro: #1e3c72;
            --azul-marino: #2a5298;
            --azul-clarisimo: #e8f4ff;
            --azul-celeste: #e1f5fe;
            --azul-nieve: #f0f7ff;
            
            /* BLANCOS/GRISES */
            --blanco: #ffffff;
            --gris-muy-claro: #f9f9f9;
            --gris-azulado: #f8fafc;
            --gris-medio: #e0e0e0;
            --gris: #c1c1c1;
            --gris-oscuro: #a1a1a1;
            
            /* VERDES (칄xito, correcto) */
            --verde: #28a745;
            --verde-oscuro: #1e7e34;
            --verde-claro: #d4edda;
            --verde-texto: #155724;
            
            /* ROJOS (Error, advertencia) */
            --rojo: #dc3545;
            --rojo-claro: #f8d7da;
            --rojo-texto: #721c24;
            
            /* GRISES NEUTRALES */
            --gris-neutral: #6c757d;
            --gris-neutral-hover: #545b62;
            --negro-suave: #333333;
            
            /* AMARILLOS (Selecci칩n, hover) */
            --amarillo-claro: #fff9c4;
            --azul-hover: #f0f7ff;
        }
        
        body {
            margin: 0;
            padding: 0;
            font-family: system-ui, -apple-system, sans-serif;
            background: linear-gradient(135deg, var(--azul-marino-oscuro) 0%, var(--azul-marino) 100%);
        }
        .crossword-cell {
            position: relative;
            transition: all 0.2s;
        }
        .crossword-cell input {
            caret-color: transparent;
        }
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        .animate-bounce {
            animation: bounce 1s infinite;
        }
        
        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: var(--gris-medio);
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb {
            background: var(--gris);
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: var(--gris-oscuro);
        }
    </style>
</head>
<body class="min-h-screen" style="background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);">
    <div id="app" class="p-3 sm:p-6"></div>

    <script>
        const wordDatabase = [
                        { word: "PYTHON", clue: "Lenguaje de programaci칩n con nombre de serpiente" },
            { word: "ALGORITMO", clue: "Secuencia de pasos para resolver un problema" },
            { word: "INTERNET", clue: "Red mundial de computadoras" },
            { word: "COMPUTADORA", clue: "M치quina electr칩nica para procesar datos" },
            { word: "ELEFANTE", clue: "Mam칤fero m치s grande de la tierra" },
            { word: "JIRAFA", clue: "Animal con el cuello m치s largo" },
            { word: "DELFIN", clue: "Mam칤fero marino inteligente" },
            { word: "TIGRE", clue: "Felino rayado asi치tico" },
            { word: "AGUILA", clue: "Ave rapaz majestuosa" },
            { word: "PINGUINO", clue: "Ave que no vuela y vive en el fr칤o" },
            { word: "ARGENTINA", clue: "Pa칤s sudamericano famoso por el tango" },
            { word: "EVEREST", clue: "Monta침a m치s alta del mundo" },
            { word: "AMAZONAS", clue: "R칤o m치s caudaloso del mundo" },
            { word: "SAHARA", clue: "Desierto m치s grande de 츼frica" },
            { word: "PACIFICO", clue: "Oc칠ano m치s grande de la Tierra" },
            { word: "GUITARRA", clue: "Instrumento de cuerdas popular" },
            { word: "PIANO", clue: "Instrumento de teclas blancas y negras" },
            { word: "VIOLIN", clue: "Instrumento de cuerda que se toca con arco" },
            { word: "BATERIA", clue: "Conjunto de tambores y platillos" },
            { word: "TROMPETA", clue: "Instrumento de viento-metal brillante" },
            { word: "FUTBOL", clue: "Deporte con bal칩n m치s popular del mundo" },
            { word: "BASQUET", clue: "Deporte que se juega con canasta" },
            { word: "TENIS", clue: "Deporte de raqueta sobre red" },
            { word: "NATACION", clue: "Deporte acu치tico ol칤mpico" },
            { word: "ATLETISMO", clue: "Deporte de carreras y saltos" },
            { word: "MANZANA", clue: "Fruta prohibida del Ed칠n" },
            { word: "PIZZA", clue: "Comida italiana redonda con queso" },
            { word: "CHOCOLATE", clue: "Dulce derivado del cacao" },
            { word: "HAMBURGUESA", clue: "S치ndwich americano con carne" },
            { word: "PASTA", clue: "Comida italiana como espaguetis" },
            { word: "MERCURIO", clue: "Planeta m치s cercano al Sol" },
            { word: "JUPITER", clue: "Planeta m치s grande del sistema solar" },
            { word: "ELECTRON", clue: "Part칤cula con carga negativa" },
            { word: "OXIGENO", clue: "Gas esencial para la respiraci칩n" },
            { word: "EINSTEIN", clue: "F칤sico de la teor칤a de la relatividad" },
            { word: "TELEVISION", clue: "Aparato para ver programas y pel칤culas" },
            { word: "CINE", clue: "Lugar donde se proyectan pel칤culas" },
            { word: "TEATRO", clue: "Arte esc칠nico con actores en vivo" },
            { word: "VIDEOJUEGO", clue: "Juego electr칩nico interactivo" },
            { word: "MUSICA", clue: "Arte de combinar sonidos" },
            { word: "ROBOT", clue: "M치quina programable autom치tica" },
            { word: "GALAXIA", clue: "Sistema estelar gigante en el espacio" },
            { word: "DINOSAURIO", clue: "Reptil extinto de la era mesozoica" },
            { word: "VOLCAN", clue: "Monta침a que expulsa lava" },
            { word: "ARCOIRIS", clue: "Fen칩meno 칩ptico con siete colores" },
            { word: "TORNADO", clue: "Torbellino de viento destructivo" },
            { word: "TERREMOTO", clue: "Movimiento s칤smico de la tierra" },
            { word: "TSUNAMI", clue: "Ola gigante marina devastadora" },
            { word: "HURACAN", clue: "Tormenta tropical poderosa" },
            { word: "RELAMPAGO", clue: "Descarga el칠ctrica en el cielo" },
            { word: "TRUENO", clue: "Sonido del rayo en tormenta" },
            { word: "NIEVE", clue: "Precipitaci칩n congelada blanca" },
            { word: "LLUVIA", clue: "Agua que cae del cielo" },
            { word: "GRANIZO", clue: "Bolas de hielo que caen" },
            { word: "NIEBLA", clue: "Nube baja que reduce visibilidad" },
            { word: "ESMERALDA", clue: "Piedra preciosa verde" },
            { word: "DIAMANTE", clue: "Gema m치s dura del mundo" },
            { word: "ZAFIRO", clue: "Piedra preciosa azul" },
            { word: "RUBI", clue: "Gema roja muy valiosa" },
            { word: "PERLA", clue: "Gema formada en ostra" },
            { word: "ORQUESTA", clue: "Conjunto grande de m칰sicos" },
            { word: "FLAUTA", clue: "Instrumento de viento de madera" },
            { word: "SAXOFON", clue: "Instrumento de jazz brillante" },
            { word: "ACORDEON", clue: "Instrumento de fuelle y teclas" },
            { word: "ARPA", clue: "Instrumento de cuerdas vertical" },
            { word: "MARACAS", clue: "Instrumento de percusi칩n latino" },
            { word: "TAMBOR", clue: "Instrumento de percusi칩n con parche" },
            { word: "CASTANUELAS", clue: "Instrumento espa침ol de dedos" },
            { word: "PLATILLOS", clue: "Discos met치licos de percusi칩n" },
            { word: "XILOFON", clue: "Instrumento de barras de madera" },
            { word: "LEON", clue: "Rey de la selva africana" },
            { word: "LEOPARDO", clue: "Felino manchado 치gil" },
            { word: "GUEPARDO", clue: "Felino m치s r치pido del mundo" },
            { word: "PANTERA", clue: "Felino negro sigiloso" },
            { word: "LOBO", clue: "C치nido salvaje que caza en manada" },
            { word: "ZORRO", clue: "C치nido astuto de cola peluda" },
            { word: "OSO", clue: "Mam칤fero grande y peludo" },
            { word: "GORILA", clue: "Primate m치s grande y fuerte" },
            { word: "CHIMPANCE", clue: "Primate inteligente africano" },
            { word: "ORANGUTAN", clue: "Primate de pelo naranja" },
            { word: "CANGURO", clue: "Marsupial australiano saltador" },
            { word: "KOALA", clue: "Marsupial que come eucalipto" },
            { word: "HIPOPOTAMO", clue: "Mam칤fero africano acu치tico" },
            { word: "RINOCERONTE", clue: "Mam칤fero con cuerno en nariz" },
            { word: "CEBRA", clue: "Equino africano rayado" },
            { word: "CAMELLO", clue: "Animal con jorobas del desierto" },
            { word: "LLAMA", clue: "Cam칠lido sudamericano andino" },
            { word: "ALPACA", clue: "Cam칠lido de lana fina" },
            { word: "VICUNA", clue: "Cam칠lido salvaje de los Andes" },
            { word: "BALLENA", clue: "Mam칤fero marino m치s grande" },
            { word: "TIBURON", clue: "Depredador marino temido" },
            { word: "PULPO", clue: "Molusco con ocho tent치culos" },
            { word: "MEDUSA", clue: "Animal marino que pica" },
            { word: "ESTRELLA", clue: "Cuerpo celeste luminoso" },
            { word: "PLANETA", clue: "Cuerpo que orbita al Sol" },
            { word: "COMETA", clue: "Objeto espacial con cola" },
            { word: "ASTEROIDE", clue: "Roca espacial peque침a" },
            { word: "METEORITO", clue: "Fragmento espacial que cae" },
            { word: "SATELITE", clue: "Objeto que orbita un planeta" },
            { word: "TELESCOPIO", clue: "Instrumento para ver estrellas" },
            { word: "ASTRONAUTA", clue: "Persona que viaja al espacio" },
            { word: "COHETE", clue: "Veh칤culo espacial propulsado" },
            { word: "ECLIPSE", clue: "Ocultaci칩n de un astro" },
            { word: "LUNA", clue: "Sat칠lite natural de la Tierra" },
            { word: "MARTE", clue: "Planeta rojo del sistema solar" },
            { word: "VENUS", clue: "Planeta m치s brillante en el cielo" },
            { word: "SATURNO", clue: "Planeta con anillos famosos" },
            { word: "NEPTUNO", clue: "Planeta m치s alejado del Sol" },
            { word: "URANO", clue: "Planeta azul verdoso inclinado" },
            { word: "PIRAMIDE", clue: "Monumento egipcio triangular" },
            { word: "ESFINGE", clue: "Escultura egipcia con cuerpo de le칩n" },
            { word: "COLISEO", clue: "Anfiteatro romano antiguo" },
            { word: "MACHU", clue: "Ciudad inca en Per칰" },
            { word: "PETRA", clue: "Ciudad tallada en roca" },
            { word: "GRAN", clue: "Muralla china antigua" },
            { word: "AJEDREZ", clue: "Juego de estrategia con rey" },
            { word: "DOMINO", clue: "Juego de fichas numeradas" },
            { word: "DAMAS", clue: "Juego de tablero con coronas" },
            { word: "MONOPOLIO", clue: "Juego de comprar propiedades" },
            { word: "POKER", clue: "Juego de cartas con apuestas" },
            { word: "RULETA", clue: "Juego de casino giratorio" },
            { word: "BIBLIOTECA", clue: "Lugar con muchos libros" },
            { word: "MUSEO", clue: "Edificio con obras de arte" },
            { word: "CASTILLO", clue: "Fortaleza medieval con torres" },
            { word: "CATEDRAL", clue: "Iglesia principal grande" },
            { word: "PUENTE", clue: "Estructura que cruza obst치culo" },
            { word: "FARO", clue: "Torre con luz para barcos" },
            { word: "MOLINO", clue: "Edificio con aspas giratorias" },
            { word: "GRANJA", clue: "Lugar donde se cr칤a ganado" },
            { word: "HUERTO", clue: "Terreno para cultivar verduras" },
            { word: "JARDIN", clue: "Espacio con plantas ornamentales" },
            { word: "PARQUE", clue: "츼rea verde recreativa p칰blica" },
            { word: "BOSQUE", clue: "츼rea extensa con muchos 치rboles" },
            { word: "SELVA", clue: "Bosque tropical denso" },
            { word: "PRADERA", clue: "Terreno extenso con hierba" },
            { word: "DESIERTO", clue: "Zona 치rida con poca vida" },
            { word: "TUNDRA", clue: "Zona polar sin 치rboles" },
            { word: "TAIGA", clue: "Bosque de con칤feras del norte" },
            { word: "PANTANO", clue: "Terreno h칰medo y fangoso" },
            { word: "LAGO", clue: "Masa de agua continental" },
            { word: "OCEANO", clue: "Gran extensi칩n de agua salada" },
            { word: "CASCADA", clue: "Ca칤da vertical de agua" },
            { word: "MANANTIAL", clue: "Fuente natural de agua" },
            { word: "GLACIAR", clue: "Masa de hielo en movimiento" },
            { word: "ICEBERG", clue: "Bloque de hielo flotante" },
            { word: "ARRECIFE", clue: "Formaci칩n coralina marina" },
            { word: "ISLA", clue: "Tierra rodeada de agua" },
            { word: "PENINSULA", clue: "Tierra rodeada por tres lados" },
            { word: "ARCHIPIELAGO", clue: "Conjunto de islas cercanas" },
            { word: "BAHIA", clue: "Entrada del mar en costa" },
            { word: "GOLFO", clue: "Entrada grande del mar" },
            { word: "ESTRECHO", clue: "Paso angosto entre mares" },
            { word: "CANAL", clue: "V칤a acu치tica artificial" },
            { word: "DELTA", clue: "Desembocadura ramificada de r칤o" },
            { word: "VALLE", clue: "Depresi칩n entre monta침as" },
            { word: "COLINA", clue: "Elevaci칩n suave del terreno" },
            { word: "ACANTILADO", clue: "Pared rocosa vertical costera" },
            { word: "CUEVA", clue: "Cavidad natural en roca" },
            { word: "CANON", clue: "Garganta profunda entre rocas" },
            { word: "MESETA", clue: "Planicie elevada extensa" },
            { word: "LLANURA", clue: "Terreno plano sin relieves" },
            { word: "CORDILLERA", clue: "Cadena de monta침as largas" },
            { word: "CUMBRE", clue: "Punto m치s alto de monta침a" },
            { word: "CRATER", clue: "Boca de un volc치n" },
            { word: "MAGMA", clue: "Roca fundida bajo tierra" },
            { word: "LAVA", clue: "Roca fundida que fluye" },
            { word: "CENIZA", clue: "Residuo de combusti칩n volc치nica" },
            { word: "CRISTAL", clue: "S칩lido transparente brillante" },
            { word: "MINERAL", clue: "Sustancia inorg치nica natural" },
            { word: "CUARZO", clue: "Mineral duro y com칰n" },
            { word: "GRANITO", clue: "Roca 칤gnea dura gris치cea" },
            { word: "MARMOL", clue: "Roca metam칩rfica pulible" },
            { word: "CARBON", clue: "Roca combustible negra" },
            { word: "PETROLEO", clue: "L칤quido combustible f칩sil" },
            { word: "GASOLINA", clue: "Combustible refinado del petr칩leo" },
            { word: "DIESEL", clue: "Combustible para motores pesados" },
            { word: "ELECTRICIDAD", clue: "Energ칤a de electrones" },
            { word: "BATERIA", clue: "Dispositivo que almacena energ칤a" },
            { word: "MOTOR", clue: "M치quina que produce movimiento" },
            { word: "ENGRANAJE", clue: "Rueda dentada de transmisi칩n" },
            { word: "PALANCA", clue: "Barra para mover cargas" },
            { word: "POLEA", clue: "Rueda con canal para cuerda" },
            { word: "TORNILLO", clue: "Sujetador con rosca helicoidal" },
            { word: "TUERCA", clue: "Pieza con rosca interna" },
            { word: "CLAVO", clue: "Varilla met치lica puntiaguda" },
            { word: "MARTILLO", clue: "Herramienta para golpear clavos" },
            { word: "DESTORNILLADOR", clue: "Herramienta para tornillos" },
            { word: "SIERRA", clue: "Herramienta dentada para cortar" },
            { word: "TALADRO", clue: "Herramienta para hacer agujeros" },
            { word: "LLAVE", clue: "Herramienta para ajustar tuercas" },
            { word: "ALICATE", clue: "Herramienta de agarre met치lico" },
            { word: "PINZA", clue: "Herramienta de sujeci칩n peque침a" },
            { word: "PALA", clue: "Herramienta para cavar tierra" },
            { word: "RASTRILLO", clue: "Herramienta con p칰as para jard칤n" },
            { word: "HACHA", clue: "Herramienta para cortar madera" },
            { word: "MACHETE", clue: "Cuchillo largo para selva" },
            { word: "CUCHILLO", clue: "Herramienta cortante de cocina" },
            { word: "TIJERA", clue: "Herramienta con dos hojas" },
            { word: "AGUJA", clue: "Herramienta fina para coser" },
            { word: "HILO", clue: "Fibra larga para coser" }
        ];

        let state = {
            grid: [],
            words: [],
            userInput: {},
            selectedCell: null,
            selectedWord: null,
            showHints: {},
            verified: false,
            wordStatus: {},
            stats: { correct: 0, incorrect: 0, total: 0 },
            showCongrats: false
        };

        function canPlaceWord(grid, word, row, col, direction, size) {
            if (row < 0 || col < 0) return false;
            
            for (let i = 0; i < word.length; i++) {
                const r = direction === 'horizontal' ? row : row + i;
                const c = direction === 'horizontal' ? col + i : col;
                
                if (r >= size || c >= size) return false;
                
                const cell = grid[r][c];
                if (cell && cell.letter !== word[i]) return false;
                
                if (!cell) {
                    const adjacentPositions = direction === 'horizontal' 
                        ? [[r-1, c], [r+1, c]]
                        : [[r, c-1], [r, c+1]];
                    
                    for (const [ar, ac] of adjacentPositions) {
                        if (ar >= 0 && ar < size && ac >= 0 && ac < size && grid[ar][ac]) {
                            return false;
                        }
                    }
                }
            }
            
            return true;
        }

        function generateCrossword() {
            const numWords = Math.floor(Math.random() * 6) + 15;
            const shuffled = [...wordDatabase].sort(() => Math.random() - 0.5);
            const selectedWords = shuffled.slice(0, numWords);
            
            const size = 20;
            const newGrid = Array(size).fill(null).map(() => Array(size).fill(null));
            const placedWords = [];

            const firstWord = selectedWords[0];
            const startRow = Math.floor(size / 2);
            const startCol = Math.floor((size - firstWord.word.length) / 2);
            
            for (let i = 0; i < firstWord.word.length; i++) {
                newGrid[startRow][startCol + i] = {
                    letter: firstWord.word[i],
                    wordIds: [0],
                    number: null
                };
            }
            
            // Asegurar que la primera celda tenga el n칰mero
            newGrid[startRow][startCol].number = 1;
            
            placedWords.push({
                id: 0,
                word: firstWord.word,
                clue: firstWord.clue,
                row: startRow,
                col: startCol,
                direction: 'horizontal',
                number: 1
            });

            let wordNumber = 2;

            for (let i = 1; i < selectedWords.length; i++) {
                const wordData = selectedWords[i];
                const word = wordData.word;
                let placed = false;
                let attempts = 0;
                const maxAttempts = 100;

                while (!placed && attempts < maxAttempts) {
                    attempts++;
                    
                    const existingWord = placedWords[Math.floor(Math.random() * placedWords.length)];
                    
                    for (let j = 0; j < word.length && !placed; j++) {
                        for (let k = 0; k < existingWord.word.length && !placed; k++) {
                            if (word[j] === existingWord.word[k]) {
                                let newRow, newCol, newDirection;
                                
                                if (existingWord.direction === 'horizontal') {
                                    newDirection = 'vertical';
                                    newRow = existingWord.row - j;
                                    newCol = existingWord.col + k;
                                } else {
                                    newDirection = 'horizontal';
                                    newRow = existingWord.row + k;
                                    newCol = existingWord.col - j;
                                }

                                if (canPlaceWord(newGrid, word, newRow, newCol, newDirection, size)) {
                                    for (let m = 0; m < word.length; m++) {
                                        const r = newDirection === 'horizontal' ? newRow : newRow + m;
                                        const c = newDirection === 'horizontal' ? newCol + m : newCol;
                                        
                                        if (!newGrid[r][c]) {
                                            newGrid[r][c] = {
                                                letter: word[m],
                                                wordIds: [i],
                                                number: null
                                            };
                                        } else {
                                            newGrid[r][c].wordIds.push(i);
                                        }
                                    }

                                    // Asegurar que la primera celda de la nueva palabra tenga el n칰mero
                                    if (!newGrid[newRow][newCol].number) {
                                        newGrid[newRow][newCol].number = wordNumber;
                                    }

                                    placedWords.push({
                                        id: i,
                                        word: word,
                                        clue: wordData.clue,
                                        row: newRow,
                                        col: newCol,
                                        direction: newDirection,
                                        number: wordNumber
                                    });
                                    
                                    wordNumber++;
                                    placed = true;
                                }
                            }
                        }
                    }
                }
            }

            state.grid = newGrid;
            state.words = placedWords;
            state.userInput = {};
            state.selectedCell = null;
            state.selectedWord = null;
            state.showHints = {};
            state.verified = false;
            state.wordStatus = {};
            state.stats = { correct: 0, incorrect: 0, total: 0 };
            state.showCongrats = false;
            
            render();
        }

        function handleCellClick(row, col) {
            if (!state.grid[row][col]) return;
            
            state.selectedCell = { row, col };
            
            const cell = state.grid[row][col];
            if (cell.wordIds.length > 0) {
                state.selectedWord = cell.wordIds[0];
            }
            
            // Solo actualizar el resaltado sin re-renderizar todo
            updateCellHighlighting();
            
            const input = document.getElementById(`cell-${row}-${col}`);
            if (input) input.focus();
        }

        function updateCellHighlighting() {
            // Actualizar colores de celdas seg칰n selecci칩n
            state.grid.forEach((row, rowIndex) => {
                row.forEach((cell, colIndex) => {
                    if (!cell) return;
                    
                    const cellDiv = document.getElementById(`cell-div-${rowIndex}-${colIndex}`);
                    if (!cellDiv) return;
                    
                    const isSelected = state.selectedCell?.row === rowIndex && state.selectedCell?.col === colIndex;
                    const isInSelectedWord = state.selectedWord !== null && cell?.wordIds?.includes(state.selectedWord);
                    const cellCorrect = getCellColor(rowIndex, colIndex);

                    let bgColor = '#333333';
                    let borderColor = 'border-gray-700';
                    
                    if (state.verified && cellCorrect !== null) {
                        bgColor = cellCorrect ? '#28a745' : '#dc3545';
                        borderColor = cellCorrect ? 'border-green-600' : 'border-red-600';
                    } else if (isSelected) {
                        bgColor = '#fff9c4';
                        borderColor = 'border-yellow-500';
                    } else if (isInSelectedWord) {
                        bgColor = '#e1f5fe';
                        borderColor = 'border-blue-400';
                    } else {
                        bgColor = '#ffffff';
                        borderColor = 'border-gray-300';
                    }

                    cellDiv.className = `crossword-cell w-7 h-7 sm:w-10 sm:h-10 border cursor-pointer ${borderColor}`;
                    cellDiv.style.background = bgColor;
                });
            });
        }

        function handleInputChange(row, col, value) {
            if (value.length > 1) return;
            
            const key = `${row}-${col}`;
            state.userInput[key] = value.toUpperCase();

            if (state.verified) {
                state.verified = false;
                state.wordStatus = {};
            }

            // Actualizar solo el valor del input sin re-renderizar todo
            const currentInput = document.getElementById(`cell-${row}-${col}`);
            if (currentInput) {
                currentInput.value = value.toUpperCase();
            }

            // Actualizar las pistas si es necesario (solo cuando se verifica)
            if (state.verified) {
                renderClues();
            }

            if (value && state.selectedWord !== null) {
                const currentWord = state.words.find(w => w.id === state.selectedWord);
                if (currentWord) {
                    const currentPosInWord = currentWord.direction === 'horizontal'
                        ? col - currentWord.col
                        : row - currentWord.row;
                    
                    if (currentPosInWord < currentWord.word.length - 1) {
                        const nextRow = currentWord.direction === 'horizontal' ? row : row + 1;
                        const nextCol = currentWord.direction === 'horizontal' ? col + 1 : col;
                        
                        state.selectedCell = { row: nextRow, col: nextCol };
                        
                        // Enfocar el siguiente input sin re-renderizar
                        const nextInput = document.getElementById(`cell-${nextRow}-${nextCol}`);
                        if (nextInput) {
                            nextInput.focus();
                        }
                    }
                }
            }
        }

        function handleKeyDown(row, col, e) {
            if ((e.key === 'Backspace' || e.key === 'Delete') && !state.userInput[`${row}-${col}`] && state.selectedWord !== null) {
                e.preventDefault();
                const currentWord = state.words.find(w => w.id === state.selectedWord);
                if (currentWord) {
                    const currentPosInWord = currentWord.direction === 'horizontal'
                        ? col - currentWord.col
                        : row - currentWord.row;
                    
                    if (currentPosInWord > 0) {
                        const prevRow = currentWord.direction === 'horizontal' ? row : row - 1;
                        const prevCol = currentWord.direction === 'horizontal' ? col - 1 : col;
                        const prevKey = `${prevRow}-${prevCol}`;
                        
                        state.selectedCell = { row: prevRow, col: prevCol };
                        state.userInput[prevKey] = '';
                        
                        // Actualizar el input anterior sin re-renderizar
                        const prevInput = document.getElementById(`cell-${prevRow}-${prevCol}`);
                        if (prevInput) {
                            prevInput.value = '';
                            prevInput.focus();
                        }
                    }
                }
            }
        }

        function verifyAnswers() {
            const newWordStatus = {};
            let correctWords = 0;
            let incorrectWords = 0;

            state.words.forEach(word => {
                let isCorrect = true;
                
                for (let i = 0; i < word.word.length; i++) {
                    const r = word.direction === 'horizontal' ? word.row : word.row + i;
                    const c = word.direction === 'horizontal' ? word.col + i : word.col;
                    const key = `${r}-${c}`;
                    
                    if (state.userInput[key] !== word.word[i]) {
                        isCorrect = false;
                        break;
                    }
                }
                
                newWordStatus[word.id] = isCorrect;
                if (isCorrect) correctWords++;
                else incorrectWords++;
            });

            state.wordStatus = newWordStatus;
            state.verified = true;
            state.stats = {
                correct: correctWords,
                incorrect: incorrectWords,
                total: state.words.length
            };

            if (correctWords === state.words.length) {
                state.showCongrats = true;
            }

            render();
        }

        function toggleHint(wordId) {
            state.showHints[wordId] = !state.showHints[wordId];
            render();
        }

        function getCellColor(row, col) {
            if (!state.verified) return null;

            const cell = state.grid[row][col];
            if (!cell) return null;

            const wordId = cell.wordIds[0];
            return state.wordStatus[wordId];
        }

        function render() {
            const app = document.getElementById('app');
            
            let html = `
                <div class="max-w-7xl mx-auto">
                    <!-- Header -->
                    <div class="text-center mb-4 sm:mb-6">
                        <h1 class="text-3xl sm:text-5xl font-bold text-white mb-2">游빌 Crucigrama Aleatorio</h1>
                        <p class="text-purple-200 text-sm sm:text-lg">춰Resuelve el crucigrama! Cada juego es 칰nico</p>
                    </div>

                    ${state.showCongrats ? `
                    <div class="fixed inset-0 bg-black/50 backdrop-blur-sm flex items-center justify-center z-50 p-4">
                        <div class="bg-gradient-to-br from-green-500 to-emerald-600 rounded-3xl p-6 sm:p-10 max-w-md w-full text-center shadow-2xl animate-bounce">
                            <div class="text-6xl sm:text-8xl mb-4">游꿀</div>
                            <h2 class="text-3xl sm:text-4xl font-bold text-white mb-4">춰Felicitaciones!</h2>
                            <p class="text-lg sm:text-xl text-white mb-6">춰Completaste el crucigrama correctamente!</p>
                            <button onclick="state.showCongrats = false; generateCrossword();" class="bg-white text-green-600 px-6 sm:px-8 py-3 sm:py-4 rounded-xl font-bold text-base sm:text-lg hover:bg-green-50 transition-all shadow-lg">
                                Jugar de nuevo
                            </button>
                        </div>
                    </div>
                    ` : ''}

                    <!-- Stats y Controles -->
                    <div class="flex flex-wrap justify-center gap-2 sm:gap-4 mb-4 sm:mb-6">
                        <div class="bg-white/10 backdrop-blur-lg rounded-xl px-3 sm:px-6 py-2 sm:py-3 border border-white/20">
                            <span class="text-white font-bold text-sm sm:text-lg">${state.words.length} palabras</span>
                        </div>
                        
                        ${state.verified ? `
                        <div class="bg-green-500/20 backdrop-blur-lg rounded-xl px-3 sm:px-6 py-2 sm:py-3 border border-green-400/30 flex items-center gap-2">
                            <svg class="text-green-400" width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>
                            <span class="text-white font-bold text-sm sm:text-lg">${state.stats.correct} correctas</span>
                        </div>
                        <div class="bg-red-500/20 backdrop-blur-lg rounded-xl px-3 sm:px-6 py-2 sm:py-3 border border-red-400/30 flex items-center gap-2">
                            <svg class="text-red-400" width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                            <span class="text-white font-bold text-sm sm:text-lg">${state.stats.incorrect} incorrectas</span>
                        </div>
                        ` : ''}
                        
                        <button onclick="verifyAnswers()" class="bg-gradient-to-r from-blue-500 to-cyan-600 text-white px-4 sm:px-6 py-2 sm:py-3 rounded-xl font-bold hover:from-blue-600 hover:to-cyan-700 transition-all flex items-center gap-2 shadow-lg text-sm sm:text-base">
                            <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg> Verificar
                        </button>
                        
                        <button onclick="generateCrossword()" class="bg-gradient-to-r from-green-500 to-emerald-600 text-white px-4 sm:px-6 py-2 sm:py-3 rounded-xl font-bold hover:from-green-600 hover:to-emerald-700 transition-all flex items-center gap-2 shadow-lg text-sm sm:text-base">
                            <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg> Nuevo
                        </button>
                    </div>

                    <div class="grid grid-cols-1 lg:grid-cols-3 gap-4 sm:gap-6">
                        <!-- Crucigrama -->
                        <div class="lg:col-span-2 bg-white/10 backdrop-blur-lg rounded-2xl p-3 sm:p-6 border border-white/20">
                            <div class="overflow-auto">
                                <div class="inline-block min-w-full">
                                    ${state.grid.map((row, rowIndex) => `
                                        <div class="flex">
                                            ${row.map((cell, colIndex) => {
                                                const key = `${rowIndex}-${colIndex}`;
                                                const isSelected = state.selectedCell?.row === rowIndex && state.selectedCell?.col === colIndex;
                                                const isInSelectedWord = state.selectedWord !== null && cell?.wordIds?.includes(state.selectedWord);
                                                const userValue = state.userInput[key] || '';
                                                const cellCorrect = getCellColor(rowIndex, colIndex);

                                                let bgColor = 'border-gray-700';
                                                let cellStyle = 'background: #333333;';
                                                if (cell) {
                                                    if (state.verified && cellCorrect !== null) {
                                                        bgColor = cellCorrect ? 'border-green-600' : 'border-red-600';
                                                        cellStyle = cellCorrect ? 'background: #28a745;' : 'background: #dc3545;';
                                                    } else if (isSelected) {
                                                        bgColor = 'border-yellow-500';
                                                        cellStyle = 'background: #fff9c4;';
                                                    } else if (isInSelectedWord) {
                                                        bgColor = 'border-blue-400';
                                                        cellStyle = 'background: #e1f5fe;';
                                                    } else {
                                                        bgColor = 'border-gray-300';
                                                        cellStyle = 'background: #ffffff;';
                                                    }
                                                }

                                                return `
                                                    <div id="cell-div-${rowIndex}-${colIndex}" class="crossword-cell w-7 h-7 sm:w-10 sm:h-10 border ${bgColor} ${cell ? 'cursor-pointer' : ''}" style="${cellStyle}"
                                                         onclick="${cell ? `handleCellClick(${rowIndex}, ${colIndex})` : ''}">
                                                        ${cell?.number ? `<span class="absolute top-0 left-0 text-[8px] sm:text-xs font-bold leading-none p-0.5" style="color: #2a5298;">${cell.number}</span>` : ''}
                                                        ${cell ? `
                                                            <input 
                                                                id="cell-${rowIndex}-${colIndex}"
                                                                type="text" 
                                                                maxlength="1" 
                                                                value="${userValue}"
                                                                oninput="handleInputChange(${rowIndex}, ${colIndex}, this.value)"
                                                                onkeydown="handleKeyDown(${rowIndex}, ${colIndex}, event)"
                                                                class="w-full h-full text-center text-base sm:text-xl font-bold uppercase bg-transparent border-none outline-none"
                                                                style="color: #333333;"
                                                            />
                                                        ` : ''}
                                                    </div>
                                                `;
                                            }).join('')}
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        </div>

                        <!-- Pistas -->
                        <div class="rounded-2xl p-3 sm:p-6 shadow-xl" style="background: #f9f9f9; border: 1px solid #e0e0e0;">
                            <h2 class="text-xl sm:text-2xl font-bold mb-3 sm:mb-4" style="color: #333333;">游닇 Pistas</h2>
                            
                            <div class="mb-4">
                                <h3 class="text-base sm:text-lg font-bold mb-2" style="color: #2a5298;">Horizontal</h3>
                                ${state.words.filter(w => w.direction === 'horizontal').sort((a, b) => a.number - b.number).map(word => `
                                    <div class="mb-2 sm:mb-3 rounded-lg p-2 sm:p-3 transition-colors" style="${
                                        state.verified 
                                            ? word.wordStatus 
                                                ? 'background: #d4edda; border: 1px solid #28a745;' 
                                                : 'background: #f8d7da; border: 1px solid #dc3545;'
                                            : 'background: #ffffff; border: 1px solid #e0e0e0;'
                                    }" onmouseover="this.style.background='#f0f7ff'" onmouseout="this.style.background='${state.verified ? (state.wordStatus[word.id] ? '#d4edda' : '#f8d7da') : '#ffffff'}'">
                                        <div class="flex items-start justify-between gap-2">
                                            <div class="flex-1">
                                                <span class="font-bold text-sm sm:text-base" style="color: #333333;">${word.number}.</span>
                                                <span class="ml-2 text-xs sm:text-base" style="color: #333333;">${word.clue}</span>
                                                ${state.showHints[word.id] ? `
                                                    <div class="text-xs sm:text-sm mt-1 font-mono" style="color: #2a5298;">${word.word}</div>
                                                ` : ''}
                                            </div>
                                            <button onclick="toggleHint(${word.id})" class="p-1 rounded flex-shrink-0 transition-colors" style="background: #e8f4ff; color: #2a5298;" onmouseover="this.style.background='#2a5298'; this.style.color='#ffffff';" onmouseout="this.style.background='#e8f4ff'; this.style.color='#2a5298';">
                                                <svg width="14" height="14" class="sm:w-4 sm:h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path></svg>
                                            </button>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>

                            <div>
                                <h3 class="text-base sm:text-lg font-bold mb-2" style="color: #2a5298;">Vertical</h3>
                                ${state.words.filter(w => w.direction === 'vertical').sort((a, b) => a.number - b.number).map(word => `
                                    <div class="mb-2 sm:mb-3 rounded-lg p-2 sm:p-3 transition-colors" style="${
                                        state.verified 
                                            ? state.wordStatus[word.id] 
                                                ? 'background: #d4edda; border: 1px solid #28a745;' 
                                                : 'background: #f8d7da; border: 1px solid #dc3545;'
                                            : 'background: #ffffff; border: 1px solid #e0e0e0;'
                                    }" onmouseover="this.style.background='#f0f7ff'" onmouseout="this.style.background='${state.verified ? (state.wordStatus[word.id] ? '#d4edda' : '#f8d7da') : '#ffffff'}'">
                                        <div class="flex items-start justify-between gap-2">
                                            <div class="flex-1">
                                                <span class="font-bold text-sm sm:text-base" style="color: #333333;">${word.number}.</span>
                                                <span class="ml-2 text-xs sm:text-base" style="color: #333333;">${word.clue}</span>
                                                ${state.showHints[word.id] ? `
                                                    <div class="text-xs sm:text-sm mt-1 font-mono" style="color: #2a5298;">${word.word}</div>
                                                ` : ''}
                                            </div>
                                            <button onclick="toggleHint(${word.id})" class="p-1 rounded flex-shrink-0 transition-colors" style="background: #e8f4ff; color: #2a5298;" onmouseover="this.style.background='#2a5298'; this.style.color='#ffffff';" onmouseout="this.style.background='#e8f4ff'; this.style.color='#2a5298';">
                                                <svg width="14" height="14" class="sm:w-4 sm:h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path></svg>
                                            </button>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    </div>

                    <!-- Instrucciones -->
                    <div class="mt-4 sm:mt-6 rounded-2xl p-3 sm:p-6 text-center shadow-lg" style="background: rgba(255,255,255,0.95); border: 1px solid #e0e0e0;">
                        <p class="text-xs sm:text-base" style="color: #333333;">
                            游눠 <strong>C칩mo jugar:</strong> Haz clic en las celdas para escribir. Presiona "Verificar" para ver resultados. 
                            Verde = correcto, Rojo = incorrecto. Usa 游눠 para pistas.
                        </p>
                    </div>
                </div>
            `;
            
            app.innerHTML = html;
            
            // Escalar el crucigrama para que quepa sin scroll
            scaleGrid();
        }

        function scaleGrid() {
            const container = document.getElementById('crossword-container');
            if (!container) return;
            
            const gridElement = container.querySelector('.inline-block');
            if (!gridElement) return;
            
            const containerWidth = container.offsetWidth;
            const containerHeight = container.offsetHeight;
            const gridWidth = gridElement.offsetWidth;
            const gridHeight = gridElement.offsetHeight;
            
            const scaleX = containerWidth / gridWidth;
            const scaleY = containerHeight / gridHeight;
            const scale = Math.min(scaleX, scaleY, 1) * 0.95; // 0.95 para dar un poco de margen
            
            gridElement.style.transform = `scale(${scale})`;
        }

        // Re-escalar cuando cambie el tama침o de la ventana
        window.addEventListener('resize', scaleGrid);

        // Inicializar el juego
        generateCrossword();
    </script>
</body>
</html>